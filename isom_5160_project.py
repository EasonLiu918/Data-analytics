# -*- coding: utf-8 -*-
"""ISOM_5160_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/199GnfCLins5QYu_Jsv0IFXvCVahBd4WB

# 🧾 ISOM 5160 Python Project – Online Shoppers Intention Dataset

#1.🧹 Data Cleaning
"""

import numpy as np
import pandas as pd

# To print multiple outputs for one cell
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = 'all'

df = pd.read_csv('online_shoppers_intention.csv')
df

# Show the number of rows and columns | 資料筆數與欄位數
df.shape

# Show column names, data types, and non-null counts | 資料型別 + 是否有缺值
df.info()

# Display the first 5 rows of the dataset | 數值欄位的統計摘要
df.head()

# Check for missing values in each column | 查看缺失值情況
df.isnull().sum()

# Check how many duplicate rows exist in the dataset | 檢查資料中有多少列是重複的
df.duplicated().sum()
# Display duplicated rows (excluding the first occurrence) | 顯示所有重複列（除了第一次出現的那一筆）
df[df.duplicated()]
# Remove duplicate rows | 移除重複列
df = df.drop_duplicates()

"""#2.🧪 Data Transformation

## 2.1 Transforming format
"""

# Convert 'Month' and 'VisitorType' to categorical type | 將 'Month' 和 'VisitorType' 欄位轉為類別型
df['Month'] = df['Month'].astype('category')
df['VisitorType'] = df['VisitorType'].astype('category')

# Convert 'Weekend' and 'Revenue' to boolean type | 將 'Weekend' and 'Revenue'欄位轉為布林型（True/False）

df['Weekend'] = df['Weekend'].astype(bool)
df['Revenue'] = df['Revenue'].astype(bool)

# 再次檢查型別
df.info()

"""## 2.2 Encoding"""

#✅ One-hot encoding is used to convert categorical columns into binary vectors | One-hot 編碼可以將類別型欄位轉換成數值欄位，讓模型能夠處理

# One-hot encode the 'Month' and 'VisitorType' columns | 對 'Month' 和 'VisitorType' 欄位進行 One-Hot 編碼
#df = pd.get_dummies(df, columns=['Month', 'VisitorType'], prefix=['Month', 'Visitor'])

# Show the new column names to verify | 顯示新的欄位名稱，確認是否成功建立 One-Hot 欄位
#df.columns

#df

"""## 2.3 Normalization"""

# ✅ Why normalize these columns? | 為什麼要正規化這些欄位？
# These numerical columns have large and varied scales | 這些數值欄位的範圍差異很大，尺度不一，
normalize_cols = [
    'Administrative', 'Administrative_Duration',
    'Informational', 'Informational_Duration',
    'ProductRelated', 'ProductRelated_Duration',
    'PageValues'
]

df[normalize_cols] = df[normalize_cols].apply(
    lambda x: (x - x.min()) / (x.max() - x.min())
)

##  Display the summary statistics to verify normalization | 顯示摘要統計值來確認正規化成功
df[normalize_cols].describe()

"""#3.📊 Data Summarization

## 3.1 Primary Statistics
"""

# Summary statistics for numerical columns | 對數值欄位做統計摘要
df.describe()

# Summary statistics for boolean columns | 對布林值欄位做統計摘要（如: Weekend, Revenue）
df[['Weekend', 'Revenue']].describe()

# Why use value_counts? | 為什麼要使用 value_counts?
# Value counts is used to summarize categorical columns by showing the frequency of each unique value | 可以幫助我們快速了解每個分類資料的分布情況，例如哪一個月、瀏覽器或訪客類型出現最多。

# Which columns are suitable? | 哪些欄位適合使用 value_counts?
# Suitable for categorical, boolean, and low-cardinality integer columns | 適合類別型（如月份、訪客類型）、布林型（如Weekend）、以及種類不多的整數欄位（如瀏覽器、系統、地區等）

# Define the natural order of months that appear in the dataset | 定義資料集中出現過的月份，並依照自然月份順序排列
month_order = ['Feb', 'Mar', 'May', 'June', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']

#Convert 'Month' column into an ordered categorical type | 將 'Month' 欄位轉換成有順序的類別型
df['Month'] = pd.Categorical(df['Month'], categories=month_order, ordered=True)

# 👉 Count month distribution | 計算每個月份的出現次數
df['Month'].value_counts().sort_index()

# 👉 Count visitor type distribution | 計算訪客類型的出現次數
df['VisitorType'].value_counts().sort_index()

# Count boolean values (True/False) | 布林型欄位統計（True/False 出現次數）
df['Weekend'].value_counts().sort_index()
df['Revenue'].value_counts().sort_index()

# Count low-cardinality integer columns representing categorical data | 其他分類型欄位統計（整數但代表分類）
df['Region'].value_counts()
df['TrafficType'].value_counts()
df['Browser'].value_counts()
df['OperatingSystems'].value_counts()

"""## 3.2 Pivot Table & GroupBy"""

# Total number of purchases per month | 每月的成交次數
df.groupby('Month')['Revenue'].sum().sort_index()

# Conversion rate per month | 每月的成交率（成交數 / 該月總數）
df.groupby('Month')['Revenue'].mean().sort_index()

# Total number of purchases per visitor type | 每種訪客類型的成交次數
df.groupby('VisitorType')['Revenue'].sum()

# Conversion rate per operating system | 每種作業系統的成交率（成交數 / 該系統總數）
df.groupby('OperatingSystems')['Revenue'].mean()

# Total number of purchases per browser type | 每種瀏覽器的成交次數
df.groupby('Browser')['Revenue'].sum()

# Conversion rate per region | 每個地區的成交率（成交數 / 地區總數）
df.groupby('Region')['Revenue'].mean()

# Pivot table: total purchases by Month and VisitorType | 交叉分析「月份」與「訪客類型」的成交次數
df.pivot_table(values='Revenue', index='Month', columns='VisitorType', aggfunc='sum', fill_value=0)

# Pivot table: conversion rate by Month and VisitorType | 交叉分析「月份」與「訪客類型」的成交率
df.pivot_table(values='Revenue', index='Month', columns='VisitorType', aggfunc='mean', fill_value=0)

# Pivot table: conversion rate by OperatingSystem and Browser | 作業系統 × 瀏覽器的成交率分析
df.pivot_table(values='Revenue', index='OperatingSystems', columns='Browser', aggfunc='mean', fill_value=0)

# Pivot table: number of purchases by Region and VisitorType | 地區 × 訪客類型 的成交次數
df.pivot_table(values='Revenue', index='Region', columns='VisitorType', aggfunc='sum', fill_value=0)

# Pivot table: purchases by Month and Weekend | 每月週末與否的成交次數分析
df.pivot_table(values='Revenue', index='Month', columns='Weekend', aggfunc='sum', fill_value=0)

# Pivot table: bounce and exit rates by month | 每月的跳出率與退出率平均
df.pivot_table(values=['BounceRates', 'ExitRates'], index='Month', aggfunc='mean')

"""#4.📈Exploratory Analysis

##4.1 Monthly Trend Analysis

###4.1.1 Monthly Conversion Trend | 每月成交率趨勢圖
"""

import matplotlib.pyplot as plt

#Compute average conversion rate per month | 計算每月平均成交率
monthly_conversion = df.groupby('Month')['Revenue'].mean().sort_index()

fig, ax = plt.subplots(figsize=(10, 5))

ax.plot(monthly_conversion.index, monthly_conversion.values, marker='o', linestyle='-', color='tab:blue')

#Add labels, title, and grid | 添加標籤、標題與網格
ax.set_title('Monthly Conversion Trend', fontsize=14)
ax.set_xlabel('Month')
ax.set_ylabel('Conversion Rate')
ax.grid(True)

#Annotate each data point | 顯示數值標籤
for i in range(len(monthly_conversion)):
    month = monthly_conversion.index[i]
    value = monthly_conversion.values[i]
    ax.text(month, value + 0.005, f'{value:.3f}')

plt.tight_layout()
plt.show()

"""###4.1.2 Monthly Revenue Volume ｜ 每月成交次數條形圖"""

#Compute total number of purchases per month ｜ 計算每月成交次數（成交 = Revenue 為 True）
monthly_volume = df.groupby('Month')['Revenue'].sum().sort_index()

fig, ax = plt.subplots(figsize=(10, 5))

ax.bar(monthly_volume.index, monthly_volume.values, color='tab:orange')

#Add title, labels, and grid ｜ 添加標題、標籤與網格線
ax.set_title('Monthly Revenue Volume', fontsize=14)
ax.set_xlabel('Month')
ax.set_ylabel('Number of Purchases')
ax.grid(True, axis='y')

#Annotate each bar ｜ 顯示成交次數數值標籤
for i in range(len(monthly_volume)):
    month = monthly_volume.index[i]
    value = monthly_volume.values[i]
    ax.text(month, value + 10, f'{int(value)}', ha='center')

plt.tight_layout()
plt.show()

"""###4.1.3 Monthly Bounce & Exit Rates | 每月跳出率與離開率趨勢圖"""

# Step 1: Compute monthly averages | 計算每月平均的跳出率與離開率
bounce_exit = df.pivot_table(values=['BounceRates', 'ExitRates'], index='Month', aggfunc='mean').sort_index()

# Step 2: Create figure and axes | 建立圖形與座標軸
fig, ax = plt.subplots(figsize=(10, 5))

# Step 3: Plot the two lines | 繪製兩條折線圖：跳出率與離開率
ax.plot(bounce_exit.index, bounce_exit['BounceRates'], marker='o', linestyle='-', color='tab:red', label='Bounce Rate')
ax.plot(bounce_exit.index, bounce_exit['ExitRates'], marker='s', linestyle='--', color='tab:blue', label='Exit Rate')

# Step 4: Add labels, grid, and legend | 加入標籤、網格與圖例
ax.set_title('Monthly Bounce and Exit Rates', fontsize=14)
ax.set_xlabel('Month')
ax.set_ylabel('Rate')
ax.grid(True)
ax.legend()

# Step 5: Annotate each value | 顯示數值標籤
for i in range(len(bounce_exit)):
    ax.text(bounce_exit.index[i], bounce_exit['BounceRates'][i] + 0.002, f"{bounce_exit['BounceRates'][i]:.3f}", color='tab:red')
    ax.text(bounce_exit.index[i], bounce_exit['ExitRates'][i] + 0.001, f"{bounce_exit['ExitRates'][i]:.3f}", color='tab:blue')

plt.tight_layout()
plt.show()

"""##4.2 Category-wise Analysis（分類變數分析）

###4.2.1 Conversion Rate by Visitor Type
"""

# Group by visitor type and calculate average conversion rate | 計算每種訪客類型的平均成交率
visitor_conversion = df.groupby('VisitorType')['Revenue'].mean()

fig, ax = plt.subplots(figsize=(8, 5))

# Define custom colors for each bar | 自訂每根柱子的顏色
colors = ['skyblue', 'lightgreen', 'salmon']

ax.bar(visitor_conversion.index, visitor_conversion.values, color=colors)

ax.set_title('Conversion Rate by Visitor Type', fontsize=14, color='darkblue')
ax.set_xlabel('Visitor Type')
ax.set_ylabel('Conversion Rate')
ax.set_ylim(0, visitor_conversion.max() + 0.05)  # 調整 y 軸上限
ax.grid(True, axis='y', linestyle='--', alpha=0.6)

# Show value labels on each bar | 每根柱子顯示數值
for i in range(len(visitor_conversion)):
    ax.text(i, visitor_conversion.values[i] + 0.01,
            f'{visitor_conversion.values[i]:.2f}',
            ha='center', color='black')

plt.tight_layout()
plt.show()

"""###4.2.2 Conversion Rate by Operation System"""

# Calculate conversion rate by Operating System | 計算每種作業系統的成交率
df['OS_Label'] = df['OperatingSystems'].map(os_map)  # Map OS codes to names | 將作業系統代碼對應為名稱
os_conv = df.groupby('OS_Label')['Revenue'].mean().sort_values()  # Group and compute mean conversion rate | 分組並計算平均成交率

fig, ax = plt.subplots(figsize=(8, 5))
bars = ax.bar(os_conv.index, os_conv.values, color='lightblue')
ax.set_title('Conversion Rate by Operating System')
ax.set_xlabel('Operation System')
ax.set_ylabel('Conversion Rate')
ax.set_ylim(0, os_conv.values.max() + 0.05)  # Set y-limit with buffer | 設定 y 軸範圍

# Add labels above bars | 在長條上方加上數值標籤
for i in range(len(os_conv)):
    ax.text(i, os_conv.values[i] + 0.01, f"{os_conv.values[i]:.3f}", ha='center')

plt.tight_layout()
plt.show()

"""### 4.2.3 Conversion Rate by Browser"""

# 🧭 Map browser codes to names ｜將瀏覽器代碼轉成名稱
df['Browser_Label'] = df['Browser'].map(browser_map)

# 📈 Compute conversion rate by browser ｜計算每種瀏覽器的平均轉換率
browser_conv = df.groupby('Browser_Label')['Revenue'].mean().sort_values()

fig, ax = plt.subplots(figsize=(10, 5))
bars = ax.bar(browser_conv.index, browser_conv.values, color='lightcoral')

ax.set_title('Conversion Rate by Browser', fontsize=14, color='darkblue')
ax.set_xlabel('Browser')
ax.set_ylabel('Conversion Rate')
ax.set_ylim(0, browser_conv.max() + 0.05)

for i, bar in enumerate(bars):
    height = bar.get_height()
    ax.text(bar.get_x() + bar.get_width() / 2,
            height + 0.01,
            f'{height:.3f}',
            ha='center', fontsize=10)

plt.tight_layout()
plt.show()

"""##4.3 Correlation Analysis

### 4.3.1 Remove Outlier
"""

# Select a numeric column for boxplot | 選擇數值型欄位來畫 boxplot
roomprice = df['ExitRates']

# Draw a boxplot to visualize outliers | 畫出 boxplot 來觀察離群值
fig, ax = plt.subplots(figsize=(10, 4))
ax.boxplot(roomprice, vert=False, showfliers=True, whis=1.5, labels=["ExitRates"])
ax.set_title('Boxplot of ExitRates', fontsize=14)
plt.show()

# Calculate IQR and bounds for outlier detection | 計算 IQR 及判定離群值的上下界
q1 = roomprice.quantile(0.25)
q3 = roomprice.quantile(0.75)
iqr = q3 - q1

left_end = q1 - 1.5 * iqr
right_end = q3 + 1.5 * iqr

print(f"The Interquartile Range (IQR) is {iqr:.2f}")
print(f"Outlier range: less than {left_end:.2f} or greater than {right_end:.2f}")

# Identify outliers | 找出離群值
outliers = df[(roomprice < left_end) | (roomprice > right_end)]
print(f"Number of outliers: {len(outliers)} ({len(outliers)/len(roomprice):.1%})")

# Select a numeric column for boxplot | 選擇數值型欄位來畫 boxplot
roomprice = df['ExitRates']

# Calculate IQR and bounds for outlier detection | 計算IQR 及判定離群值的上下界
q1 = roomprice.quantile(0.25)
q3 = roomprice.quantile(0.75)
iqr = q3 - q1

# 使用 whisker = 1.5 來界定離群值範圍
whisker = 1.5
left_end = q1 - whisker * iqr
right_end = q3 + whisker * iqr

# Calculate the percentage of the outliers | 計算離群值的比例
outliers = df[(roomprice < left_end) | (roomprice > right_end)]
print(f"The Interquartile Range (IQR) is {iqr:.2f}")
print(f"Outlier range: less than {left_end:.2f} or greater than {right_end:.2f}")
print(f"Number of outliers: {len(outliers)} ({len(outliers)/len(roomprice):.1%})")

# Remove the outliers outside the specified range | 移除離群值
df = df[(roomprice >= left_end) & (roomprice <= right_end)]

# Print the shape of the DataFrame after removing outliers | 刪除後印出資料數量
print(df.shape)

# Select the cleaned numeric column for boxplot ｜ 選擇清理後的數值欄位來畫 boxplot
roomprice = df['ExitRates']

# Draw a boxplot to visualize outliers ｜ 畫出 boxplot 來確認是否還有離群值
fig, ax = plt.subplots(figsize=(10, 4))
ax.boxplot(roomprice, vert=False, showfliers=True, whis=1.5, labels=["ExitRates"])
ax.set_title('Boxplot of ExitRates (after removing outliers)', fontsize=14)
plt.show()

"""###4.3.2 Correlation with Revenue"""

# Import necessary libraries | 匯入必要的函式庫
import matplotlib.pyplot as plt
import seaborn as sns

# Compute correlation matrix using numeric columns only | 計算數值型欄位的相關係數矩陣
corr = df.corr(numeric_only=True)

# Create a heatmap to visualize the correlation matrix | 建立熱力圖來視覺化相關性矩陣
plt.figure(figsize=(13, 10))

# Draw the heatmap with color scale from -1 to 1 | 畫出相關性熱力圖，範圍從 -1 到 1
ax = sns.heatmap(corr, vmin=-1, vmax=1, annot=True, center=0,
                 cmap=sns.diverging_palette(30, 240, n=200))

# Rotate x-axis labels for better readability | 旋轉 x 軸標籤以提高可讀性
ax.set_xticklabels(ax.get_xticklabels(), rotation=45, horizontalalignment='right')

# Set title | 設置標題
plt.title('Correlation Matrix of Numeric Features', fontsize=14)

plt.tight_layout()
plt.show()

# Select correlations with Revenue only | 選取和 Revenue 的相關係數
revenue_corr = corr['Revenue'].drop('Revenue').sort_values(key=abs, ascending=False)

# Display top 5 features | 顯示前5個特徵
print(revenue_corr.head(5))

# Plot bar chart for top correlations | 繪製與 Revenue 最高相關性的特徵
plt.figure(figsize=(8, 5))
sns.barplot(x=revenue_corr.head(5).values, y=revenue_corr.head(5).index, palette='coolwarm')

plt.title('Top 5 Features Correlated with Revenue', fontsize=14)
plt.xlabel('Correlation Coefficient')
plt.ylabel('Feature')
plt.grid(axis='x', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

"""### 4.3.3 Correlation Matrix


"""

# 📊 Compute the correlation matrix | 計算相關係數矩陣
corr_matrix = df.corr(numeric_only=True)

# 🔄 Flatten the correlation matrix into feature pairs | 將相關係數矩陣轉換成變數對列表
corr_pairs = corr_matrix.unstack().reset_index()
corr_pairs.columns = ['Feature1', 'Feature2', 'Correlation']

# Remove self-correlation pairs (correlation = 1.0) | 移除自己跟自己比較的情況
corr_pairs = corr_pairs[corr_pairs['Feature1'] != corr_pairs['Feature2']]

# Drop duplicate pairs (A-B and B-A are the same) | 移除重複的變數對（A-B 和 B-A 視為一樣）
corr_pairs['Set'] = corr_pairs.apply(lambda row: frozenset([row['Feature1'], row['Feature2']]), axis=1)
corr_pairs = corr_pairs.drop_duplicates(subset='Set').drop(columns='Set')

# Sort to get Top 5 positive and negative feature pairs | 排序並分別取出Top 5正相關和負相關變數對
top5_positive = corr_pairs.sort_values(by='Correlation', ascending=False).head(5)
top5_negative = corr_pairs.sort_values(by='Correlation', ascending=True).head(5)

# Display the results | 顯示結果
print("Top 5 Positive Correlated Feature Pairs")
print(top5_positive)

print("\nTop 5 Negative Correlated Feature Pairs")
print(top5_negative)

# 📊 Visualize selected feature pairs with Pair Plot | 使用Pair Plot可視化篩選的變數對

import seaborn as sns
import matplotlib.pyplot as plt

# Select important features | 選擇重要的特徵
selected_features = list(set(top5_positive['Feature1'].tolist() +
                             top5_positive['Feature2'].tolist() +
                             top5_negative['Feature1'].tolist() +
                             top5_negative['Feature2'].tolist()))

# Subset the dataframe | 提取這些特徵的子集
subset_df = df[selected_features]

# Create pair plot | 畫出pair plot
sns.pairplot(subset_df, corner=True)
plt.suptitle('Pair Plot of Top Correlated Features', y=1.02, fontsize=16)
plt.tight_layout()
plt.show()